diff --git a/Makefile.am b/Makefile.am
index a733b52..bc315df 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -19,7 +19,7 @@
 #  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 #  PERFORMANCE OF THIS SOFTWARE.
 
-SUBDIRS = src include
+SUBDIRS = src include wrapper
 
 pkgconfigdir = $(libdir)/pkgconfig
 pkgconfig_DATA = xvmc.pc
diff --git a/configure.ac b/configure.ac
index 6a904dd..5fb8113 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,59 +1,60 @@
-dnl  Copyright 2005 Red Hat, Inc.
-dnl 
-dnl  Permission to use, copy, modify, distribute, and sell this software and its
-dnl  documentation for any purpose is hereby granted without fee, provided that
-dnl  the above copyright notice appear in all copies and that both that
-dnl  copyright notice and this permission notice appear in supporting
-dnl  documentation, and that the name of Red Hat not be used in
-dnl  advertising or publicity pertaining to distribution of the software without
-dnl  specific, written prior permission.  Red Hat makes no
-dnl  representations about the suitability of this software for any purpose.  It
-dnl  is provided "as is" without express or implied warranty.
-dnl 
-dnl  RED HAT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
-dnl  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
-dnl  EVENT SHALL RED HAT BE LIABLE FOR ANY SPECIAL, INDIRECT OR
-dnl  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-dnl  DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
-dnl  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
-dnl  PERFORMANCE OF THIS SOFTWARE.
-dnl
-dnl Process this file with autoconf to create configure.
-
+#  Copyright 2005 Red Hat, Inc.
+#
+#  Permission to use, copy, modify, distribute, and sell this software and its
+#  documentation for any purpose is hereby granted without fee, provided that
+#  the above copyright notice appear in all copies and that both that
+#  copyright notice and this permission notice appear in supporting
+#  documentation, and that the name of Red Hat not be used in
+#  advertising or publicity pertaining to distribution of the software without
+#  specific, written prior permission.  Red Hat makes no
+#  representations about the suitability of this software for any purpose.  It
+#  is provided "as is" without express or implied warranty.
+#
+#  RED HAT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+#  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+#  EVENT SHALL RED HAT BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+#  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+#  DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+#  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+#  PERFORMANCE OF THIS SOFTWARE.
+#
+
+# Initialize Autoconf
 AC_PREREQ([2.60])
+AC_INIT([libXvMC], [1.0.6],
+	[https://bugs.freedesktop.org/enter_bug.cgi?product=xorg], [libXvMC])
+AC_CONFIG_SRCDIR([Makefile.am])
+AC_CONFIG_HEADERS([config.h])
 
-AC_INIT([libXvMC],
-	[1.0.6],
-	[https://bugs.freedesktop.org/enter_bug.cgi?product=xorg],
-	[libXvMC])
+# Initialize Automake
 AM_INIT_AUTOMAKE([foreign dist-bzip2])
 AM_MAINTAINER_MODE
 
-# Require xorg-macros: XORG_DEFAULT_OPTIONS
+# Initialize libtool
+AC_PROG_LIBTOOL
+
+# Require X.Org macros 1.8 or later for AC_PROG_INSTALL
 m4_ifndef([XORG_MACROS_VERSION],
-          [m4_fatal([must install xorg-macros 1.3 or later before running autoconf/autogen])])
-XORG_MACROS_VERSION(1.3)
+          [m4_fatal([must install xorg-macros 1.8 or later before running autoconf/autogen])])
+XORG_MACROS_VERSION(1.8)
 XORG_DEFAULT_OPTIONS
-AM_CONFIG_HEADER(config.h)
-
-# Check for progs
-AC_PROG_LIBTOOL
+XORG_CHECK_MALLOC_ZERO
 
-# Check for dependencies
+# Obtain compiler/linker options for depedencies
 PKG_CHECK_MODULES(XVMC, x11 xext xv xextproto videoproto)
 
-AC_CHECK_FUNC([shmat], AC_DEFINE(HAS_SHM,1,[Has shm*() functions]))
+# Checks for library functions.
+AC_CHECK_FUNCS([shmat])
 		  
-XORG_CHECK_MALLOC_ZERO
-
-dnl Allow checking code with lint, sparse, etc.
+# Allow checking code with lint, sparse, etc.
 XORG_WITH_LINT
 LINT_FLAGS="${LINT_FLAGS} ${XVMC_CFLAGS}"
 
-
-AC_OUTPUT([Makefile
-           include/Makefile
-	   include/X11/Makefile
-	   include/X11/extensions/Makefile
-	   src/Makefile
-           xvmc.pc])
+AC_CONFIG_FILES([Makefile
+		include/Makefile
+		include/X11/Makefile
+		include/X11/extensions/Makefile
+		src/Makefile
+		wrapper/Makefile
+		xvmc.pc])
+AC_OUTPUT
diff --git a/src/Makefile.am b/src/Makefile.am
index 741e7c5..05284fe 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1,34 +1,16 @@
-lib_LTLIBRARIES = libXvMC.la libXvMCW.la
+lib_LTLIBRARIES = libXvMC.la
 
-libXvMC_la_SOURCES = \
-         XvMC.c \
-         XvMClibint.h
-
-libXvMCW_la_SOURCES = \
-	XvMCWrapper.c
-
-AM_CFLAGS = $(CWARNFLAGS) @XVMC_CFLAGS@
-AM_CPPFLAGS = -I$(top_srcdir)/include @MALLOC_ZERO_CFLAGS@
-
-libXvMC_la_LIBADD = @XVMC_LIBS@
-libXvMC_la_CFLAGS = $(AM_CFLAGS)
-
-libXvMCW_la_LIBADD = @XVMC_LIBS@
-libXvMCW_la_CFLAGS =				\
-	$(AM_CFLAGS)				\
-	-DXVMC_CONFIGDIR=$(sysconfdir)/X11		\
-	-DXVMC_SOVERSION=\".1.0\"		\
-	-DXV_SOVERSION=\".1.0\"
+AM_CPPFLAGS = -I$(top_srcdir)/include $(MALLOC_ZERO_CFLAGS)
+AM_CFLAGS = $(CWARNFLAGS) $(XVMC_CFLAGS)
 
+libXvMC_la_SOURCES = XvMC.c XvMClibint.h
+libXvMC_la_LIBADD = $(XVMC_LIBS)
 libXvMC_la_LDFLAGS = -version-number 1:0:0 -no-undefined
-libXvMCW_la_LDFLAGS = -version-number 1:0:0 -no-undefined
-
 
 if LINT
-ALL_LINT_FLAGS=$(LINT_FLAGS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+ALL_LINT_FLAGS=$(LINT_FLAGS) $(DEFS) $(DEFAULT_INCLUDES) \
                 $(AM_CPPFLAGS) $(CPPFLAGS)
 
 lint:
-	$(LINT) $(ALL_LINT_FLAGS) $(libXvMC_la_SOURCES) $(XVMC_LIBS)
-	$(LINT) $(ALL_LINT_FLAGS) $(libXvMCW_la_CFLAGS) $(libXvMCW_la_SOURCES) $(XVMC_LIBS)
+	$(LINT) $(ALL_LINT_FLAGS) $(libXvMC_la_SOURCES) $(AM_CFLAGS) $(XVMC_LIBS)
 endif LINT
diff --git a/src/XvMC.c b/src/XvMC.c
index 3bf5a43..eb8e7e8 100644
--- a/src/XvMC.c
+++ b/src/XvMC.c
@@ -3,7 +3,7 @@
 #endif
 #include <stdio.h>
 #include "XvMClibint.h"
-#ifdef HAS_SHM
+#ifdef HAVE_SHMAT
 #ifndef Lynx
 #include <sys/ipc.h>
 #include <sys/shm.h>
@@ -11,7 +11,7 @@
 #include <ipc.h>
 #include <shm.h>
 #endif /* Lynx */
-#endif /* HAS_SHM */
+#endif /* HAVE_SHMAT */
 #include <unistd.h>
 #include <sys/time.h>
 #include <X11/extensions/Xext.h>
@@ -487,7 +487,7 @@ Status XvMCGetDRInfo(Display *dpy, XvPortID port,
     char *tmpBuf = NULL;
     CARD32 magic;
 
-#ifdef HAS_SHM
+#ifdef HAVE_SHMAT
     volatile CARD32 *shMem;
     struct timezone here;
     struct timeval now;
@@ -503,7 +503,7 @@ Status XvMCGetDRInfo(Display *dpy, XvPortID port,
     req->port = port;
     magic = 0;
     req->magic = 0;
-#ifdef HAS_SHM 
+#ifdef HAVE_SHMAT
     req->shmKey = shmget(IPC_PRIVATE, 1024, IPC_CREAT | 0600);
 
     /*
@@ -541,14 +541,14 @@ Status XvMCGetDRInfo(Display *dpy, XvPortID port,
     if (!_XReply (dpy, (xReply *) &rep, 0, xFalse)) {
         UnlockDisplay (dpy);
         SyncHandle ();
-#ifdef HAS_SHM
+#ifdef HAVE_SHMAT
 	if ( req->shmKey >= 0) {
 	    shmdt( (const void *) shMem );
 	}            
 #endif
         return -1;
     }
-#ifdef HAS_SHM
+#ifdef HAVE_SHMAT
     shmdt( (const void *) shMem );
 #endif
 
diff --git a/src/XvMCWrapper.c b/src/XvMCWrapper.c
deleted file mode 100644
index d3800e7..0000000
--- a/src/XvMCWrapper.c
+++ /dev/null
@@ -1,781 +0,0 @@
-/*****************************************************************************
- * XvMC Wrapper including the Nonstandard VLD extension.
- *
- * Copyright (c) 2004 The Unichrome project. All rights reserved.
- *
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHOR(S) OR COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Author: Thomas Hellström (2004)
- */
-
-/*
- * BUGS: The wrapper really should maintain one symbol table per port. This 
- * could possibly be impemented, To do that, the port-independent symbols need to be lifted out,
- * and one would have to create a number of mapping tables:
- *
- *                 port  -> symbol table
- *                 context -> port
- *                 surface -> port
- *                 subpicture -> port
- *
- * and reference the right table when needed. 
- * This needs to be done only if there is a player that wants to access two displays with different
- * hardware simultaneously. Not likely as of today.
- */
-
-#ifdef HAVE_CONFIG_H
-  #include "config.h"
-#endif
-
-#include <X11/Xlib.h>
-#include <X11/extensions/XvMC.h>
-#include <X11/extensions/XvMClib.h>
-#include <X11/extensions/vldXvMC.h>
-#include <dlfcn.h>
-#include <stdio.h>
-#include <string.h>
-#include <ctype.h>
-#include <stdlib.h>
-
-
-typedef Bool (*XvMCQueryExtensionP) (Display *, int *, int *);
-typedef Status (*XvMCQueryVersionP) (Display *, int *,int *);
-typedef XvMCSurfaceInfo * (*XvMCListSurfaceTypesP)(Display *, XvPortID, int *);
-typedef Status (* XvMCCreateContextP) (Display *,XvPortID,int ,int ,int ,int ,XvMCContext * );
-typedef Status (*XvMCDestroyContextP) (Display *, XvMCContext * );
-typedef Status (*XvMCCreateSurfaceP)(Display *,XvMCContext *,XvMCSurface *);
-typedef Status (*XvMCDestroySurfaceP)(Display *, XvMCSurface *);
-typedef XvImageFormatValues * (*XvMCListSubpictureTypesP) (Display *,XvPortID ,int ,int *);
-typedef Status (*XvMCPutSurfaceP)(Display *,XvMCSurface *,Drawable ,short , short , unsigned short , 
-				  unsigned short ,short ,short ,unsigned short ,unsigned short ,int );
-typedef Status (*XvMCHideSurfaceP)(Display *, XvMCSurface *);
-typedef Status (*XvMCCreateSubpictureP) (Display *, XvMCContext *, XvMCSubpicture *, 
-					 unsigned short, unsigned short,int);
-typedef Status (*XvMCClearSubpictureP) (Display *,XvMCSubpicture *,short,short,unsigned short,unsigned short,
-					unsigned int);
-typedef Status (*XvMCCompositeSubpictureP) (Display *, XvMCSubpicture *,XvImage *,short,short,
-					    unsigned short, unsigned short,short,short);
-typedef Status (*XvMCDestroySubpictureP) (Display *, XvMCSubpicture *);
-typedef Status (*XvMCSetSubpicturePaletteP) (Display *, XvMCSubpicture *, unsigned char *);
-typedef Status (*XvMCBlendSubpictureP) (Display *d,XvMCSurface *,XvMCSubpicture *,short,
-					short,unsigned short,unsigned short,short,short,
-					unsigned short,unsigned short);
-typedef Status (*XvMCBlendSubpicture2P) (Display *,XvMCSurface *,XvMCSurface *,
-					 XvMCSubpicture *,short,short,unsigned short,
-					 unsigned short,short,short,unsigned short,
-					 unsigned short);
-typedef Status (*XvMCSyncSurfaceP) (Display *, XvMCSurface *);
-typedef Status (*XvMCFlushSurfaceP) (Display *, XvMCSurface *);
-typedef Status (*XvMCGetSurfaceStatusP) (Display *, XvMCSurface *, int *);
-typedef Status (*XvMCRenderSurfaceP) (Display *,XvMCContext *,unsigned int,XvMCSurface *,
-				      XvMCSurface *,XvMCSurface *,unsigned int,unsigned int,
-				      unsigned int,XvMCMacroBlockArray *,XvMCBlockArray *);
-typedef Status (*XvMCSyncSubpictureP) (Display *, XvMCSubpicture *);
-typedef Status (*XvMCFlushSubpictureP) (Display *, XvMCSubpicture *);
-typedef Status (*XvMCGetSubpictureStatusP) (Display *, XvMCSubpicture *, int *);
-typedef Status (*XvMCCreateBlocksP) (Display *, XvMCContext *,unsigned int,XvMCBlockArray *);
-typedef Status (*XvMCDestroyBlocksP) (Display *,XvMCBlockArray *);
-typedef Status (*XvMCCreateMacroBlocksP) (Display *,XvMCContext *,unsigned int,
-					  XvMCMacroBlockArray *);
-typedef Status (*XvMCDestroyMacroBlocksP) (Display *,XvMCMacroBlockArray *);
-typedef XvAttribute *(*XvMCQueryAttributesP) (Display *,XvMCContext *,int *);
-typedef Status (*XvMCSetAttributeP) (Display *,XvMCContext *, Atom, int);
-typedef Status (*XvMCGetAttributeP) (Display *,XvMCContext *, Atom, int *);
-
-/*
- * Nonstandard VLD acceleration level:
- */ 
-  
-typedef Status (*XvMCBeginSurfaceP) (Display *,XvMCContext *,XvMCSurface *,
-				     XvMCSurface *,XvMCSurface *f,const XvMCMpegControl *);
-typedef Status (*XvMCLoadQMatrixP) (Display *, XvMCContext *,const XvMCQMatrix *);
-typedef Status (*XvMCPutSliceP)(Display *,XvMCContext *, char *,int);
-typedef Status (*XvMCPutSlice2P)(Display *,XvMCContext *, char *,int, unsigned);
-typedef Status (*XvMCGetDRInfoP)(Display *, XvPortID, char **, char **, int *, int *, 
-				  int *, int *);
-
-
-typedef struct {
-    XvMCQueryExtensionP   XvMCQueryExtension; 
-    XvMCQueryVersionP   XvMCQueryVersion; 
-    XvMCListSurfaceTypesP  XvMCListSurfaceTypes;
-    XvMCCreateContextP   XvMCCreateContext; 
-    XvMCDestroyContextP   XvMCDestroyContext; 
-    XvMCCreateSurfaceP  XvMCCreateSurface;
-    XvMCDestroySurfaceP  XvMCDestroySurface;
-    XvMCListSubpictureTypesP    XvMCListSubpictureTypes; 
-    XvMCPutSurfaceP   XvMCPutSurface;
-    XvMCHideSurfaceP   XvMCHideSurface;
-    XvMCCreateSubpictureP   XvMCCreateSubpicture;
-    XvMCClearSubpictureP     XvMCClearSubpicture; 			      
-    XvMCCompositeSubpictureP    XvMCCompositeSubpicture; 
-    XvMCDestroySubpictureP    XvMCDestroySubpicture; 
-    XvMCSetSubpicturePaletteP    XvMCSetSubpicturePalette; 
-    XvMCBlendSubpictureP    XvMCBlendSubpicture; 
-    XvMCBlendSubpicture2P   XvMCBlendSubpicture2;
-    XvMCSyncSurfaceP    XvMCSyncSurface; 
-    XvMCFlushSurfaceP    XvMCFlushSurface; 
-    XvMCGetSurfaceStatusP    XvMCGetSurfaceStatus; 
-    XvMCRenderSurfaceP    XvMCRenderSurface; 
-    XvMCSyncSubpictureP    XvMCSyncSubpicture; 
-    XvMCFlushSubpictureP    XvMCFlushSubpicture; 
-    XvMCGetSubpictureStatusP    XvMCGetSubpictureStatus; 
-    XvMCCreateBlocksP    XvMCCreateBlocks; 
-    XvMCDestroyBlocksP    XvMCDestroyBlocks; 
-    XvMCCreateMacroBlocksP   XvMCCreateMacroBlocks;
-    XvMCDestroyMacroBlocksP    XvMCDestroyMacroBlocks; 
-    XvMCQueryAttributesP    XvMCQueryAttributes; 
-    XvMCSetAttributeP    XvMCSetAttribute; 
-    XvMCGetAttributeP    XvMCGetAttribute; 
-
-    /*
-     * Nonstandard VLD acceleration level:
-     */ 
-  
-    XvMCBeginSurfaceP    XvMCBeginSurface; 
-    XvMCLoadQMatrixP    XvMCLoadQMatrix; 
-    XvMCPutSliceP   XvMCPutSlice;
-    XvMCPutSlice2P   XvMCPutSlice2;
-
-    /*
-     * Driver name function.
-     */
-
-    XvMCGetDRInfoP XvMCGetDRInfo;
-
-    int preInitialised;
-    int initialised;
-    int vldextension;
-} XvMCWrapper;
-
-static XvMCWrapper xW;
-static int wrapperInit = 0;
-static int wrapperPreInit = 0;
-static void *xvhandle;
-static void *handle2;
-
-#define BUFLEN 200
-
-#define STRS(ARG) STR(ARG)
-#define STR(ARG) #ARG
-
-#define XW_RSYM(base,handle,handle2,pointer, retval)			\
-    do {								\
-	register char *err;						\
-	base.pointer = (pointer##P) dlsym((handle),#pointer);		\
-	if ((err = dlerror()) != NULL) {				\
-	    if (!handle2) {						\
-		fprintf(stderr,"%s\n",err); return retval;		\
-	    }								\
-	    base.pointer = (pointer##P) dlsym((handle2),#pointer);	\
-	    if ((err = dlerror()) != NULL) {				\
-		fprintf(stderr,"%s\n",err); return retval;		\
-	    }								\
-	}								\
-    } while (0);
-
-#define XW_RSYM2(base,handle,handle2,pointer)			\
-    base.pointer = (pointer##P) dlsym((handle),#pointer);	\
-    if (dlerror() != NULL) {					\
-	base.pointer = (pointer##P) dlsym((handle2),#pointer);	\
-	if (dlerror() != NULL) return;				\
-    }							
-
-
-/*
- * Try to dlopen a shared library, versionless first.
- */
-
-
-static void  *dlopenversion(const char *lib, const char *version, int flag) 
-{
-  void *ret;
-  int curLen,verLen;
-  char *curName;
-  const char *tail;
-
-  
-  curLen = strlen(lib) + (verLen = strlen(version)) + 1;
-  curName = (char *) malloc(curLen * sizeof(char));
-  strncpy( curName, lib, curLen);
-  if (verLen > 1) {
-    if (NULL != (tail = strstr(version+1,"."))) {
-      strncat( curName, version, tail - version);
-    } else {
-      strncat( curName, version, verLen);
-    }
-  }
-  ret = dlopen(curName, flag);
-  free(curName);
-  return ret;
-}
-
-static int preInitW(Display *dpy) 
-{
-
-    /*
-     * Resolve functions that are not hw driver specific.
-     */
-
-    void *handleZ = NULL;
-
-    wrapperPreInit = 1;
-    xW.preInitialised = 0;
-    xW.initialised = 0;
-    xvhandle = dlopenversion("libXv.so", XV_SOVERSION, RTLD_LAZY | RTLD_GLOBAL);
-    if (!xvhandle) {
-	fprintf(stderr,"XvMCWrapper: Warning! Could not open shared "
-		"library \"libXv.so" XV_SOVERSION "\"\nThis may cause relocation "
-		"errors later.\nError was: \"%s\".\n",dlerror());
-    } 
-    handle2 = dlopenversion("libXvMC.so", XVMC_SOVERSION, RTLD_LAZY | RTLD_GLOBAL);
-    if (!handle2) {
-	fprintf(stderr,"XvMCWrapper: Could not load XvMC "
-		"library \"libXvMC.so" XVMC_SOVERSION "\". Failing\n");
-	fprintf(stderr,"%s\n",dlerror());
-	return 1;
-    }
-    XW_RSYM(xW, handle2, handleZ, XvMCQueryExtension, 1);
-    XW_RSYM(xW, handle2, handleZ, XvMCQueryVersion, 1);
-    xW.preInitialised = 1;
-    return 0;
-}
-
-static void initW(Display *dpy, XvPortID port) 
-{
-    char nameBuffer[BUFLEN];
-    void *handle;
-    int tmp;
-    char *clientName = NULL;
-    char *err;
-    FILE *configFile; 
-    int nameLen = 0;
-    int major,minor,patchLevel,isLocal;
-    char *busID = NULL;
-
-    wrapperInit = 1;
-    xW.initialised = 0;
-
-    if (!wrapperPreInit) 
-	if (preInitW( dpy )) return;
-
-    /*
-     * Will the DDX tell us the client driver name?
-     */ 
-
-    xW.XvMCGetDRInfo = (XvMCGetDRInfoP)
-	dlsym(handle2,"XvMCGetDRInfo");
-
-    if ((err = dlerror()) == NULL) {
-	if (0 == xW.XvMCGetDRInfo( dpy, port, &clientName, &busID, &major, 
-				    &minor,&patchLevel, &isLocal)) {
-	    nameLen = strlen(clientName);
-	    XFree(busID);
-	    if (!isLocal) {
-		fprintf(stderr,"XvMCWrapper: X server is not local. Cannot run XvMC.\n");
-		XFree(clientName);
-		return;
-	    }
-	} else {
-	    clientName = NULL;
-	}
-    } 
-
-    if (clientName && (nameLen < BUFLEN-7) && (nameLen > 0)) {
-	nameLen += 3;
-	strncpy(nameBuffer,"lib",BUFLEN-1);
-	strncpy(nameBuffer+3, clientName, BUFLEN-4);
-	strncpy(nameBuffer + nameLen, ".so", BUFLEN-nameLen-1);
-	nameBuffer[BUFLEN-1] = 0;
-	XFree(clientName);
-	handle = dlopenversion(nameBuffer, XVMC_SOVERSION,RTLD_LAZY);
-    } else {
-	/*
-	 * No. Try to obtain it from the config file.
-	 */
-      
-	if (clientName) XFree(clientName);
-
-	configFile = fopen(STRS(XVMC_CONFIGDIR) "/XvMCConfig","r");
-      
-	xW.initialised = 0;
-	xW.vldextension = 0;
-
-	if (NULL == configFile) {
-	    fprintf(stderr,"XvMCWrapper: Could not open config file \"%s\".\n",
-		    STRS(XVMC_CONFIGDIR) "/XvMCConfig");
-	    perror("XvMCWrapper");
-	    return;
-	}
-
-	if (NULL == fgets(nameBuffer, BUFLEN, configFile)) {
-	    fclose(configFile);
-	    fprintf(stderr,"XvMCWrapper: Could not read XvMC library name.\n");
-	    perror("XvMCWrapper");
-	    return;
-	}
-	
-	fclose(configFile);
-	if ((tmp = strlen(nameBuffer)) == 0) {
-	    fprintf(stderr,"XvMCWrapper: Zero length XvMC library name.\n");
-	    fprintf(stderr,"%s\n",dlerror());
-	    return;
-	}
-
-	/*
-	 * Skip trailing newlines and garbage.
-	 */
-	
-	while (iscntrl(nameBuffer[tmp-1])) {
-	    nameBuffer[tmp-1] = 0;
-	    if (--tmp == 0) {
-		fprintf(stderr,"XvMCWrapper: Zero length XvMC library name.\n");
-		return;
-	    }
-	}
-	handle = dlopen(nameBuffer,RTLD_LAZY);
-    }
-    if (!handle) {
-	fprintf(stderr,"XvMCWrapper: Could not load hardware specific XvMC "
-		"library \"%s\".\n",nameBuffer);
-	fprintf(stderr,"%s\n",dlerror());
-	return;
-    }
-
-    XW_RSYM(xW, handle, handle2, XvMCListSurfaceTypes,);
-    XW_RSYM(xW, handle, handle2, XvMCCreateContext,);
-    XW_RSYM(xW, handle, handle2, XvMCDestroyContext,);
-    XW_RSYM(xW, handle, handle2, XvMCCreateSurface,);
-    XW_RSYM(xW, handle, handle2, XvMCDestroySurface,);
-    XW_RSYM(xW, handle, handle2, XvMCListSubpictureTypes,);
-    XW_RSYM(xW, handle, handle2, XvMCHideSurface,);
-    XW_RSYM(xW, handle, handle2, XvMCCreateSubpicture,);
-    XW_RSYM(xW, handle, handle2, XvMCClearSubpicture,);
-    XW_RSYM(xW, handle, handle2, XvMCCompositeSubpicture,);
-    XW_RSYM(xW, handle, handle2, XvMCDestroySubpicture,);
-    XW_RSYM(xW, handle, handle2, XvMCSetSubpicturePalette,);
-    XW_RSYM(xW, handle, handle2, XvMCBlendSubpicture,);
-    XW_RSYM(xW, handle, handle2, XvMCBlendSubpicture2,);
-    XW_RSYM(xW, handle, handle2, XvMCPutSurface,);
-    XW_RSYM(xW, handle, handle2, XvMCSyncSurface,);
-    XW_RSYM(xW, handle, handle2, XvMCFlushSurface,);
-    XW_RSYM(xW, handle, handle2, XvMCGetSurfaceStatus,);
-    XW_RSYM(xW, handle, handle2, XvMCRenderSurface,);
-    XW_RSYM(xW, handle, handle2, XvMCSyncSubpicture,);
-    XW_RSYM(xW, handle, handle2, XvMCFlushSubpicture,);
-    XW_RSYM(xW, handle, handle2, XvMCGetSubpictureStatus,);
-    XW_RSYM(xW, handle, handle2, XvMCCreateBlocks,);
-    XW_RSYM(xW, handle, handle2, XvMCDestroyBlocks,);
-    XW_RSYM(xW, handle, handle2, XvMCCreateMacroBlocks,);
-    XW_RSYM(xW, handle, handle2, XvMCDestroyMacroBlocks,);
-    XW_RSYM(xW, handle, handle2, XvMCQueryAttributes,);
-    XW_RSYM(xW, handle, handle2, XvMCSetAttribute,);
-    XW_RSYM(xW, handle, handle2, XvMCGetAttribute,);
-    xW.initialised = 1;
-    XW_RSYM2(xW, handle, handle2, XvMCBeginSurface);
-    XW_RSYM(xW, handle, handle2, XvMCLoadQMatrix,);
-    XW_RSYM(xW, handle, handle2, XvMCPutSlice,);
-    XW_RSYM(xW, handle, handle2, XvMCPutSlice2,);
-    xW.vldextension = 1;
-}
-
-
-Bool XvMCQueryExtension (Display *display, int *eventBase, int *errBase)
-{
-    if (!wrapperPreInit) preInitW( display );
-    if (!xW.preInitialised) return 0;
-    return (*xW.XvMCQueryExtension)(display, eventBase, errBase);
-}
-
-Status XvMCQueryVersion (Display *display, int *major_versionp,
-			 int *minor_versionp)
-{
-    if (!wrapperPreInit) preInitW( display );
-    if (!xW.preInitialised) return 0;
-    return (*xW.XvMCQueryVersion)(display, major_versionp, minor_versionp);
-}
-
-
-XvMCSurfaceInfo * XvMCListSurfaceTypes(Display *dpy, XvPortID port, int *num) 
-{
-    if (!wrapperInit) initW( dpy, port);
-    if (!xW.initialised) return NULL;
-    return (*xW.XvMCListSurfaceTypes)(dpy, port, num);
-}
-
-Status XvMCCreateContext (
-    Display *display,
-    XvPortID port,
-    int surface_type_id,
-    int width,
-    int height,
-    int flags,
-    XvMCContext * context
-    )
-{
-    if (!wrapperInit) initW(display, port);
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCCreateContext)(display, port, surface_type_id,
-				   width, height, flags, context);
-}
-
-Status XvMCDestroyContext (Display *display, XvMCContext * context)
-{
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCDestroyContext)(display, context);
-}
-
-Status 
-XvMCCreateSurface(
-    Display *display,
-    XvMCContext * context,
-    XvMCSurface * surface
-    )
-{
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCCreateSurface)(display, context, surface);
-}
-
-Status XvMCDestroySurface(Display *display, XvMCSurface *surface)
-{
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCDestroySurface)(display, surface);
-}
-
-
-XvImageFormatValues * XvMCListSubpictureTypes (
-    Display * display,
-    XvPortID port,
-    int surface_type_id,
-    int *count_return
-    )
-{
-    if (!xW.initialised) return NULL;
-    return (*xW.XvMCListSubpictureTypes)(display, port, surface_type_id,
-					 count_return);
-}
-
-
-Status
-XvMCPutSurface(
-    Display *display,
-    XvMCSurface *surface,
-    Drawable draw,
-    short srcx, 
-    short srcy, 
-    unsigned short srcw, 
-    unsigned short srch,
-    short destx,
-    short desty,
-    unsigned short destw,
-    unsigned short desth,
-    int flags
-    )
-{
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCPutSurface)(display, surface, draw, srcx, srcy, srcw, srch,
-				destx, desty, destw, desth, flags);
-}
-
-Status XvMCHideSurface(Display *display, XvMCSurface *surface)
-{
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCHideSurface)(display, surface);
-}
-
-
-Status
-XvMCCreateSubpicture (
-    Display *display, 
-    XvMCContext *context,
-    XvMCSubpicture *subpicture, 
-    unsigned short width,
-    unsigned short height,
-    int xvimage_id
-    )
-{
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCCreateSubpicture)(display, context, subpicture, width, height,
-				      xvimage_id);
-}
-
-
-Status
-XvMCClearSubpicture (
-    Display *display,
-    XvMCSubpicture *subpicture,
-    short x,
-    short y,
-    unsigned short width,
-    unsigned short height,
-    unsigned int color
-    )
-{
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCClearSubpicture)(display, subpicture, x, y, width, height, color);
-}
-
-
-Status
-XvMCCompositeSubpicture (
-    Display *display,
-    XvMCSubpicture *subpicture,
-    XvImage *image,
-    short srcx,
-    short srcy,
-    unsigned short width,
-    unsigned short height,
-    short dstx,
-    short dsty
-    )
-{
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCCompositeSubpicture)(display, subpicture, image, srcx, srcy,
-					 width, height, dstx, dsty);
-}
-
-Status
-XvMCDestroySubpicture (Display *display, XvMCSubpicture *subpicture)
-{
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCDestroySubpicture)(display, subpicture);
-}
-
-Status
-XvMCSetSubpicturePalette (
-    Display *display, 
-    XvMCSubpicture *subpicture, 
-    unsigned char *palette
-    )
-{
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCSetSubpicturePalette)(display, subpicture, palette);
-}
-
-
-Status
-XvMCBlendSubpicture (
-    Display *display,
-    XvMCSurface *target_surface,
-    XvMCSubpicture *subpicture,
-    short subx,
-    short suby,
-    unsigned short subw,
-    unsigned short subh,
-    short surfx,
-    short surfy,
-    unsigned short surfw,
-    unsigned short surfh
-    )
-{
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCBlendSubpicture)(display, target_surface, subpicture,
-				     subx, suby, subw, subh, surfx, surfy,
-				     surfw, surfh);
-}
-
-Status
-XvMCBlendSubpicture2 (
-    Display *display,
-    XvMCSurface *source_surface,
-    XvMCSurface *target_surface,
-    XvMCSubpicture *subpicture,
-    short subx,
-    short suby,
-    unsigned short subw,
-    unsigned short subh,
-    short surfx,
-    short surfy,
-    unsigned short surfw,
-    unsigned short surfh
-    )
-{
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCBlendSubpicture2)(display, source_surface, target_surface, subpicture,
-				      subx, suby, subw, subh, surfx, surfy, surfw, surfh);
-}
-
-
-Status XvMCSyncSurface (Display *display, XvMCSurface *surface)
-{
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCSyncSurface)(display, surface);
-}
-
-Status XvMCFlushSurface (Display *display, XvMCSurface *surface)
-{
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCFlushSurface)(display, surface);
-}
-
-Status XvMCGetSurfaceStatus (Display *display, XvMCSurface *surface, int *stat)
-{
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCGetSurfaceStatus)(display, surface, stat);
-}
-
-Status XvMCRenderSurface ( 
-    Display *display,
-    XvMCContext *context,
-    unsigned int picture_structure,
-    XvMCSurface *target_surface,
-    XvMCSurface *past_surface,
-    XvMCSurface *future_surface,
-    unsigned int flags,
-    unsigned int num_macroblocks,
-    unsigned int first_macroblock,
-    XvMCMacroBlockArray *macroblock_array,
-    XvMCBlockArray *blocks
-    )
-{
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCRenderSurface)(display, context, picture_structure, target_surface,
-				   past_surface, future_surface, flags, num_macroblocks,
-				   first_macroblock, macroblock_array, blocks);
-}
-
-Status XvMCSyncSubpicture (Display *display, XvMCSubpicture *subpicture)
-{
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCSyncSubpicture)(display, subpicture);
-}
-
-Status XvMCFlushSubpicture (Display *display, XvMCSubpicture *subpicture)
-{
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCFlushSubpicture)(display, subpicture);
-}
-Status
-XvMCGetSubpictureStatus (Display *display, XvMCSubpicture *subpic, int *stat)
-{
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCGetSubpictureStatus)(display, subpic, stat);
-}
-
-Status XvMCCreateBlocks (
-    Display *display, 
-    XvMCContext *context,
-    unsigned int num_blocks,
-    XvMCBlockArray *block
-    )
-{
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCCreateBlocks)(display, context, num_blocks, block);
-}
-
-
-Status XvMCDestroyBlocks (Display *display,XvMCBlockArray *block)
-{
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCDestroyBlocks)(display, block);
-}
-
-Status XvMCCreateMacroBlocks (
-    Display *display,
-    XvMCContext *context,
-    unsigned int num_blocks,
-    XvMCMacroBlockArray *blocks
-    )
-{
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCCreateMacroBlocks)(display, context, num_blocks, blocks);
-}
-
-
-Status XvMCDestroyMacroBlocks (
-    Display *display,
-    XvMCMacroBlockArray *block
-    )
-{
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCDestroyMacroBlocks)(display, block);
-}
-
-
-XvAttribute *
-XvMCQueryAttributes (
-    Display *display,
-    XvMCContext *context,
-    int *number
-    )
-{
-    if (!xW.initialised) return NULL;
-    return (*xW.XvMCQueryAttributes)(display, context, number);
-}
-  
-
-Status
-XvMCSetAttribute (
-    Display *display,
-    XvMCContext *context, 
-    Atom attribute, 
-    int value
-    )
-{
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCSetAttribute)(display, context, attribute, value);
-}
-
-
-Status
-XvMCGetAttribute (
-    Display *display,
-    XvMCContext *context, 
-    Atom attribute, 
-    int *value
-    )
-{
-    if (!xW.initialised) return BadValue;
-    return (*xW.XvMCGetAttribute)(display, context, attribute, value);
-}
-
-
-Status XvMCBeginSurface(Display *display,
-			XvMCContext *context,
-			XvMCSurface *target_surface,
-			XvMCSurface *past_surface,
-			XvMCSurface *future_surface,
-			const XvMCMpegControl *control)
-{
-    if (!xW.vldextension) return BadValue;
-    return (*xW.XvMCBeginSurface)(display, context, target_surface, past_surface, future_surface, 
-				  control);
-}
-
-Status XvMCLoadQMatrix(Display *display, XvMCContext *context,
-		       const XvMCQMatrix *qmx)
-{
-    if (!xW.vldextension) return BadValue;
-    return (*xW.XvMCLoadQMatrix)(display, context, qmx);
-}
-
-Status XvMCPutSlice(Display *display,XvMCContext *context,
-		    char *slice, int nBytes)
-{
-    if (!xW.vldextension) return BadValue;
-    return (*xW.XvMCPutSlice)(display, context, slice, nBytes);
-}
-
-Status XvMCPutSlice2(Display *display,XvMCContext *context,
-		     char *slice, int nBytes, int sliceCode)
-{
-    if (!xW.vldextension) return BadValue;
-    return (*xW.XvMCPutSlice2)(display, context, slice, nBytes, sliceCode);
-}
diff --git a/wrapper/Makefile.am b/wrapper/Makefile.am
new file mode 100644
index 0000000..b3a1c21
--- /dev/null
+++ b/wrapper/Makefile.am
@@ -0,0 +1,22 @@
+lib_LTLIBRARIES = libXvMCW.la
+
+AM_CPPFLAGS = 					\
+	-I$(top_srcdir)/include			\
+	$(MALLOC_ZERO_CFLAGS)			\
+	-DXVMC_CONFIGDIR=$(sysconfdir)/X11	\
+	-DXVMC_SOVERSION=\".1.0\"		\
+	-DXV_SOVERSION=\".1.0\"
+
+AM_CFLAGS = $(CWARNFLAGS) $(XVMC_CFLAGS)
+
+libXvMCW_la_SOURCES = XvMCWrapper.c
+libXvMCW_la_LIBADD = $(XVMC_LIBS)
+libXvMCW_la_LDFLAGS = -version-number 1:0:0 -no-undefined
+
+if LINT
+ALL_LINT_FLAGS=$(LINT_FLAGS) $(DEFS) $(DEFAULT_INCLUDES) \
+                $(AM_CPPFLAGS) $(CPPFLAGS)
+
+lint:
+	$(LINT) $(ALL_LINT_FLAGS) $(libXvMCW_la_SOURCES) $(AM_CFLAGS) $(XVMC_LIBS)
+endif LINT
diff --git a/wrapper/XvMCWrapper.c b/wrapper/XvMCWrapper.c
new file mode 100644
index 0000000..bff5a8b
--- /dev/null
+++ b/wrapper/XvMCWrapper.c
@@ -0,0 +1,781 @@
+/*****************************************************************************
+ * XvMC Wrapper including the Nonstandard VLD extension.
+ *
+ * Copyright (c) 2004 The Unichrome project. All rights reserved.
+ *
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHOR(S) OR COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Thomas Hellström (2004)
+ */
+
+/*
+ * BUGS: The wrapper really should maintain one symbol table per port. This
+ * could possibly be impemented, To do that, the port-independent symbols need to be lifted out,
+ * and one would have to create a number of mapping tables:
+ *
+ *                 port  -> symbol table
+ *                 context -> port
+ *                 surface -> port
+ *                 subpicture -> port
+ *
+ * and reference the right table when needed.
+ * This needs to be done only if there is a player that wants to access two displays with different
+ * hardware simultaneously. Not likely as of today.
+ */
+
+#ifdef HAVE_CONFIG_H
+  #include "config.h"
+#endif
+
+#include <X11/Xlib.h>
+#include <X11/extensions/XvMC.h>
+#include <X11/extensions/XvMClib.h>
+#include <X11/extensions/vldXvMC.h>
+#include <dlfcn.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdlib.h>
+
+
+typedef Bool (*XvMCQueryExtensionP) (Display *, int *, int *);
+typedef Status (*XvMCQueryVersionP) (Display *, int *,int *);
+typedef XvMCSurfaceInfo * (*XvMCListSurfaceTypesP)(Display *, XvPortID, int *);
+typedef Status (* XvMCCreateContextP) (Display *,XvPortID,int ,int ,int ,int ,XvMCContext * );
+typedef Status (*XvMCDestroyContextP) (Display *, XvMCContext * );
+typedef Status (*XvMCCreateSurfaceP)(Display *,XvMCContext *,XvMCSurface *);
+typedef Status (*XvMCDestroySurfaceP)(Display *, XvMCSurface *);
+typedef XvImageFormatValues * (*XvMCListSubpictureTypesP) (Display *,XvPortID ,int ,int *);
+typedef Status (*XvMCPutSurfaceP)(Display *,XvMCSurface *,Drawable ,short , short , unsigned short ,
+				  unsigned short ,short ,short ,unsigned short ,unsigned short ,int );
+typedef Status (*XvMCHideSurfaceP)(Display *, XvMCSurface *);
+typedef Status (*XvMCCreateSubpictureP) (Display *, XvMCContext *, XvMCSubpicture *,
+					 unsigned short, unsigned short,int);
+typedef Status (*XvMCClearSubpictureP) (Display *,XvMCSubpicture *,short,short,unsigned short,unsigned short,
+					unsigned int);
+typedef Status (*XvMCCompositeSubpictureP) (Display *, XvMCSubpicture *,XvImage *,short,short,
+					    unsigned short, unsigned short,short,short);
+typedef Status (*XvMCDestroySubpictureP) (Display *, XvMCSubpicture *);
+typedef Status (*XvMCSetSubpicturePaletteP) (Display *, XvMCSubpicture *, unsigned char *);
+typedef Status (*XvMCBlendSubpictureP) (Display *d,XvMCSurface *,XvMCSubpicture *,short,
+					short,unsigned short,unsigned short,short,short,
+					unsigned short,unsigned short);
+typedef Status (*XvMCBlendSubpicture2P) (Display *,XvMCSurface *,XvMCSurface *,
+					 XvMCSubpicture *,short,short,unsigned short,
+					 unsigned short,short,short,unsigned short,
+					 unsigned short);
+typedef Status (*XvMCSyncSurfaceP) (Display *, XvMCSurface *);
+typedef Status (*XvMCFlushSurfaceP) (Display *, XvMCSurface *);
+typedef Status (*XvMCGetSurfaceStatusP) (Display *, XvMCSurface *, int *);
+typedef Status (*XvMCRenderSurfaceP) (Display *,XvMCContext *,unsigned int,XvMCSurface *,
+				      XvMCSurface *,XvMCSurface *,unsigned int,unsigned int,
+				      unsigned int,XvMCMacroBlockArray *,XvMCBlockArray *);
+typedef Status (*XvMCSyncSubpictureP) (Display *, XvMCSubpicture *);
+typedef Status (*XvMCFlushSubpictureP) (Display *, XvMCSubpicture *);
+typedef Status (*XvMCGetSubpictureStatusP) (Display *, XvMCSubpicture *, int *);
+typedef Status (*XvMCCreateBlocksP) (Display *, XvMCContext *,unsigned int,XvMCBlockArray *);
+typedef Status (*XvMCDestroyBlocksP) (Display *,XvMCBlockArray *);
+typedef Status (*XvMCCreateMacroBlocksP) (Display *,XvMCContext *,unsigned int,
+					  XvMCMacroBlockArray *);
+typedef Status (*XvMCDestroyMacroBlocksP) (Display *,XvMCMacroBlockArray *);
+typedef XvAttribute *(*XvMCQueryAttributesP) (Display *,XvMCContext *,int *);
+typedef Status (*XvMCSetAttributeP) (Display *,XvMCContext *, Atom, int);
+typedef Status (*XvMCGetAttributeP) (Display *,XvMCContext *, Atom, int *);
+
+/*
+ * Nonstandard VLD acceleration level:
+ */
+
+typedef Status (*XvMCBeginSurfaceP) (Display *,XvMCContext *,XvMCSurface *,
+				     XvMCSurface *,XvMCSurface *f,const XvMCMpegControl *);
+typedef Status (*XvMCLoadQMatrixP) (Display *, XvMCContext *,const XvMCQMatrix *);
+typedef Status (*XvMCPutSliceP)(Display *,XvMCContext *, char *,int);
+typedef Status (*XvMCPutSlice2P)(Display *,XvMCContext *, char *,int, unsigned);
+typedef Status (*XvMCGetDRInfoP)(Display *, XvPortID, char **, char **, int *, int *,
+				  int *, int *);
+
+
+typedef struct {
+    XvMCQueryExtensionP   XvMCQueryExtension;
+    XvMCQueryVersionP   XvMCQueryVersion;
+    XvMCListSurfaceTypesP  XvMCListSurfaceTypes;
+    XvMCCreateContextP   XvMCCreateContext;
+    XvMCDestroyContextP   XvMCDestroyContext;
+    XvMCCreateSurfaceP  XvMCCreateSurface;
+    XvMCDestroySurfaceP  XvMCDestroySurface;
+    XvMCListSubpictureTypesP    XvMCListSubpictureTypes;
+    XvMCPutSurfaceP   XvMCPutSurface;
+    XvMCHideSurfaceP   XvMCHideSurface;
+    XvMCCreateSubpictureP   XvMCCreateSubpicture;
+    XvMCClearSubpictureP     XvMCClearSubpicture;
+    XvMCCompositeSubpictureP    XvMCCompositeSubpicture;
+    XvMCDestroySubpictureP    XvMCDestroySubpicture;
+    XvMCSetSubpicturePaletteP    XvMCSetSubpicturePalette;
+    XvMCBlendSubpictureP    XvMCBlendSubpicture;
+    XvMCBlendSubpicture2P   XvMCBlendSubpicture2;
+    XvMCSyncSurfaceP    XvMCSyncSurface;
+    XvMCFlushSurfaceP    XvMCFlushSurface;
+    XvMCGetSurfaceStatusP    XvMCGetSurfaceStatus;
+    XvMCRenderSurfaceP    XvMCRenderSurface;
+    XvMCSyncSubpictureP    XvMCSyncSubpicture;
+    XvMCFlushSubpictureP    XvMCFlushSubpicture;
+    XvMCGetSubpictureStatusP    XvMCGetSubpictureStatus;
+    XvMCCreateBlocksP    XvMCCreateBlocks;
+    XvMCDestroyBlocksP    XvMCDestroyBlocks;
+    XvMCCreateMacroBlocksP   XvMCCreateMacroBlocks;
+    XvMCDestroyMacroBlocksP    XvMCDestroyMacroBlocks;
+    XvMCQueryAttributesP    XvMCQueryAttributes;
+    XvMCSetAttributeP    XvMCSetAttribute;
+    XvMCGetAttributeP    XvMCGetAttribute;
+
+    /*
+     * Nonstandard VLD acceleration level:
+     */
+
+    XvMCBeginSurfaceP    XvMCBeginSurface;
+    XvMCLoadQMatrixP    XvMCLoadQMatrix;
+    XvMCPutSliceP   XvMCPutSlice;
+    XvMCPutSlice2P   XvMCPutSlice2;
+
+    /*
+     * Driver name function.
+     */
+
+    XvMCGetDRInfoP XvMCGetDRInfo;
+
+    int preInitialised;
+    int initialised;
+    int vldextension;
+} XvMCWrapper;
+
+static XvMCWrapper xW;
+static int wrapperInit = 0;
+static int wrapperPreInit = 0;
+static void *xvhandle;
+static void *handle2;
+
+#define BUFLEN 200
+
+#define STRS(ARG) STR(ARG)
+#define STR(ARG) #ARG
+
+#define XW_RSYM(base,handle,handle2,pointer, retval)			\
+    do {								\
+	register char *err;						\
+	base.pointer = (pointer##P) dlsym((handle),#pointer);		\
+	if ((err = dlerror()) != NULL) {				\
+	    if (!handle2) {						\
+		fprintf(stderr,"%s\n",err); return retval;		\
+	    }								\
+	    base.pointer = (pointer##P) dlsym((handle2),#pointer);	\
+	    if ((err = dlerror()) != NULL) {				\
+		fprintf(stderr,"%s\n",err); return retval;		\
+	    }								\
+	}								\
+    } while (0);
+
+#define XW_RSYM2(base,handle,handle2,pointer)			\
+    base.pointer = (pointer##P) dlsym((handle),#pointer);	\
+    if (dlerror() != NULL) {					\
+	base.pointer = (pointer##P) dlsym((handle2),#pointer);	\
+	if (dlerror() != NULL) return;				\
+    }
+
+
+/*
+ * Try to dlopen a shared library, versionless first.
+ */
+
+
+static void  *dlopenversion(const char *lib, const char *version, int flag)
+{
+  void *ret;
+  int curLen,verLen;
+  char *curName;
+  const char *tail;
+
+
+  curLen = strlen(lib) + (verLen = strlen(version)) + 1;
+  curName = (char *) malloc(curLen * sizeof(char));
+  strncpy( curName, lib, curLen);
+  if (verLen > 1) {
+    if (NULL != (tail = strstr(version+1,"."))) {
+      strncat( curName, version, tail - version);
+    } else {
+      strncat( curName, version, verLen);
+    }
+  }
+  ret = dlopen(curName, flag);
+  free(curName);
+  return ret;
+}
+
+static int preInitW(Display *dpy)
+{
+
+    /*
+     * Resolve functions that are not hw driver specific.
+     */
+
+    void *handleZ = NULL;
+
+    wrapperPreInit = 1;
+    xW.preInitialised = 0;
+    xW.initialised = 0;
+    xvhandle = dlopenversion("libXv.so", XV_SOVERSION, RTLD_LAZY | RTLD_GLOBAL);
+    if (!xvhandle) {
+	fprintf(stderr,"XvMCWrapper: Warning! Could not open shared "
+		"library \"libXv.so" XV_SOVERSION "\"\nThis may cause relocation "
+		"errors later.\nError was: \"%s\".\n",dlerror());
+    }
+    handle2 = dlopenversion("libXvMC.so", XVMC_SOVERSION, RTLD_LAZY | RTLD_GLOBAL);
+    if (!handle2) {
+	fprintf(stderr,"XvMCWrapper: Could not load XvMC "
+		"library \"libXvMC.so" XVMC_SOVERSION "\". Failing\n");
+	fprintf(stderr,"%s\n",dlerror());
+	return 1;
+    }
+    XW_RSYM(xW, handle2, handleZ, XvMCQueryExtension, 1);
+    XW_RSYM(xW, handle2, handleZ, XvMCQueryVersion, 1);
+    xW.preInitialised = 1;
+    return 0;
+}
+
+static void initW(Display *dpy, XvPortID port)
+{
+    char nameBuffer[BUFLEN];
+    void *handle;
+    int tmp;
+    char *clientName = NULL;
+    char *err;
+    FILE *configFile;
+    int nameLen = 0;
+    int major,minor,patchLevel,isLocal;
+    char *busID = NULL;
+
+    wrapperInit = 1;
+    xW.initialised = 0;
+
+    if (!wrapperPreInit)
+	if (preInitW( dpy )) return;
+
+    /*
+     * Will the DDX tell us the client driver name?
+     */
+
+    xW.XvMCGetDRInfo = (XvMCGetDRInfoP)
+	dlsym(handle2,"XvMCGetDRInfo");
+
+    if ((err = dlerror()) == NULL) {
+	if (0 == xW.XvMCGetDRInfo( dpy, port, &clientName, &busID, &major,
+				    &minor,&patchLevel, &isLocal)) {
+	    nameLen = strlen(clientName);
+	    XFree(busID);
+	    if (!isLocal) {
+		fprintf(stderr,"XvMCWrapper: X server is not local. Cannot run XvMC.\n");
+		XFree(clientName);
+		return;
+	    }
+	} else {
+	    clientName = NULL;
+	}
+    }
+
+    if (clientName && (nameLen < BUFLEN-7) && (nameLen > 0)) {
+	nameLen += 3;
+	strncpy(nameBuffer,"lib",BUFLEN-1);
+	strncpy(nameBuffer+3, clientName, BUFLEN-4);
+	strncpy(nameBuffer + nameLen, ".so", BUFLEN-nameLen-1);
+	nameBuffer[BUFLEN-1] = 0;
+	XFree(clientName);
+	handle = dlopenversion(nameBuffer, XVMC_SOVERSION,RTLD_LAZY);
+    } else {
+	/*
+	 * No. Try to obtain it from the config file.
+	 */
+
+	if (clientName) XFree(clientName);
+
+	configFile = fopen(STRS(XVMC_CONFIGDIR) "/XvMCConfig","r");
+
+	xW.initialised = 0;
+	xW.vldextension = 0;
+
+	if (NULL == configFile) {
+	    fprintf(stderr,"XvMCWrapper: Could not open config file \"%s\".\n",
+		    STRS(XVMC_CONFIGDIR) "/XvMCConfig");
+	    perror("XvMCWrapper");
+	    return;
+	}
+
+	if (NULL == fgets(nameBuffer, BUFLEN, configFile)) {
+	    fclose(configFile);
+	    fprintf(stderr,"XvMCWrapper: Could not read XvMC library name.\n");
+	    perror("XvMCWrapper");
+	    return;
+	}
+
+	fclose(configFile);
+	if ((tmp = strlen(nameBuffer)) == 0) {
+	    fprintf(stderr,"XvMCWrapper: Zero length XvMC library name.\n");
+	    fprintf(stderr,"%s\n",dlerror());
+	    return;
+	}
+
+	/*
+	 * Skip trailing newlines and garbage.
+	 */
+
+	while (iscntrl(nameBuffer[tmp-1])) {
+	    nameBuffer[tmp-1] = 0;
+	    if (--tmp == 0) {
+		fprintf(stderr,"XvMCWrapper: Zero length XvMC library name.\n");
+		return;
+	    }
+	}
+	handle = dlopen(nameBuffer,RTLD_LAZY);
+    }
+    if (!handle) {
+	fprintf(stderr,"XvMCWrapper: Could not load hardware specific XvMC "
+		"library \"%s\".\n",nameBuffer);
+	fprintf(stderr,"%s\n",dlerror());
+	return;
+    }
+
+    XW_RSYM(xW, handle, handle2, XvMCListSurfaceTypes,);
+    XW_RSYM(xW, handle, handle2, XvMCCreateContext,);
+    XW_RSYM(xW, handle, handle2, XvMCDestroyContext,);
+    XW_RSYM(xW, handle, handle2, XvMCCreateSurface,);
+    XW_RSYM(xW, handle, handle2, XvMCDestroySurface,);
+    XW_RSYM(xW, handle, handle2, XvMCListSubpictureTypes,);
+    XW_RSYM(xW, handle, handle2, XvMCHideSurface,);
+    XW_RSYM(xW, handle, handle2, XvMCCreateSubpicture,);
+    XW_RSYM(xW, handle, handle2, XvMCClearSubpicture,);
+    XW_RSYM(xW, handle, handle2, XvMCCompositeSubpicture,);
+    XW_RSYM(xW, handle, handle2, XvMCDestroySubpicture,);
+    XW_RSYM(xW, handle, handle2, XvMCSetSubpicturePalette,);
+    XW_RSYM(xW, handle, handle2, XvMCBlendSubpicture,);
+    XW_RSYM(xW, handle, handle2, XvMCBlendSubpicture2,);
+    XW_RSYM(xW, handle, handle2, XvMCPutSurface,);
+    XW_RSYM(xW, handle, handle2, XvMCSyncSurface,);
+    XW_RSYM(xW, handle, handle2, XvMCFlushSurface,);
+    XW_RSYM(xW, handle, handle2, XvMCGetSurfaceStatus,);
+    XW_RSYM(xW, handle, handle2, XvMCRenderSurface,);
+    XW_RSYM(xW, handle, handle2, XvMCSyncSubpicture,);
+    XW_RSYM(xW, handle, handle2, XvMCFlushSubpicture,);
+    XW_RSYM(xW, handle, handle2, XvMCGetSubpictureStatus,);
+    XW_RSYM(xW, handle, handle2, XvMCCreateBlocks,);
+    XW_RSYM(xW, handle, handle2, XvMCDestroyBlocks,);
+    XW_RSYM(xW, handle, handle2, XvMCCreateMacroBlocks,);
+    XW_RSYM(xW, handle, handle2, XvMCDestroyMacroBlocks,);
+    XW_RSYM(xW, handle, handle2, XvMCQueryAttributes,);
+    XW_RSYM(xW, handle, handle2, XvMCSetAttribute,);
+    XW_RSYM(xW, handle, handle2, XvMCGetAttribute,);
+    xW.initialised = 1;
+    XW_RSYM2(xW, handle, handle2, XvMCBeginSurface);
+    XW_RSYM(xW, handle, handle2, XvMCLoadQMatrix,);
+    XW_RSYM(xW, handle, handle2, XvMCPutSlice,);
+    XW_RSYM(xW, handle, handle2, XvMCPutSlice2,);
+    xW.vldextension = 1;
+}
+
+
+Bool XvMCQueryExtension (Display *display, int *eventBase, int *errBase)
+{
+    if (!wrapperPreInit) preInitW( display );
+    if (!xW.preInitialised) return 0;
+    return (*xW.XvMCQueryExtension)(display, eventBase, errBase);
+}
+
+Status XvMCQueryVersion (Display *display, int *major_versionp,
+			 int *minor_versionp)
+{
+    if (!wrapperPreInit) preInitW( display );
+    if (!xW.preInitialised) return 0;
+    return (*xW.XvMCQueryVersion)(display, major_versionp, minor_versionp);
+}
+
+
+XvMCSurfaceInfo * XvMCListSurfaceTypes(Display *dpy, XvPortID port, int *num)
+{
+    if (!wrapperInit) initW( dpy, port);
+    if (!xW.initialised) return NULL;
+    return (*xW.XvMCListSurfaceTypes)(dpy, port, num);
+}
+
+Status XvMCCreateContext (
+    Display *display,
+    XvPortID port,
+    int surface_type_id,
+    int width,
+    int height,
+    int flags,
+    XvMCContext * context
+    )
+{
+    if (!wrapperInit) initW(display, port);
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCCreateContext)(display, port, surface_type_id,
+				   width, height, flags, context);
+}
+
+Status XvMCDestroyContext (Display *display, XvMCContext * context)
+{
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCDestroyContext)(display, context);
+}
+
+Status
+XvMCCreateSurface(
+    Display *display,
+    XvMCContext * context,
+    XvMCSurface * surface
+    )
+{
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCCreateSurface)(display, context, surface);
+}
+
+Status XvMCDestroySurface(Display *display, XvMCSurface *surface)
+{
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCDestroySurface)(display, surface);
+}
+
+
+XvImageFormatValues * XvMCListSubpictureTypes (
+    Display * display,
+    XvPortID port,
+    int surface_type_id,
+    int *count_return
+    )
+{
+    if (!xW.initialised) return NULL;
+    return (*xW.XvMCListSubpictureTypes)(display, port, surface_type_id,
+					 count_return);
+}
+
+
+Status
+XvMCPutSurface(
+    Display *display,
+    XvMCSurface *surface,
+    Drawable draw,
+    short srcx,
+    short srcy,
+    unsigned short srcw,
+    unsigned short srch,
+    short destx,
+    short desty,
+    unsigned short destw,
+    unsigned short desth,
+    int flags
+    )
+{
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCPutSurface)(display, surface, draw, srcx, srcy, srcw, srch,
+				destx, desty, destw, desth, flags);
+}
+
+Status XvMCHideSurface(Display *display, XvMCSurface *surface)
+{
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCHideSurface)(display, surface);
+}
+
+
+Status
+XvMCCreateSubpicture (
+    Display *display,
+    XvMCContext *context,
+    XvMCSubpicture *subpicture,
+    unsigned short width,
+    unsigned short height,
+    int xvimage_id
+    )
+{
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCCreateSubpicture)(display, context, subpicture, width, height,
+				      xvimage_id);
+}
+
+
+Status
+XvMCClearSubpicture (
+    Display *display,
+    XvMCSubpicture *subpicture,
+    short x,
+    short y,
+    unsigned short width,
+    unsigned short height,
+    unsigned int color
+    )
+{
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCClearSubpicture)(display, subpicture, x, y, width, height, color);
+}
+
+
+Status
+XvMCCompositeSubpicture (
+    Display *display,
+    XvMCSubpicture *subpicture,
+    XvImage *image,
+    short srcx,
+    short srcy,
+    unsigned short width,
+    unsigned short height,
+    short dstx,
+    short dsty
+    )
+{
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCCompositeSubpicture)(display, subpicture, image, srcx, srcy,
+					 width, height, dstx, dsty);
+}
+
+Status
+XvMCDestroySubpicture (Display *display, XvMCSubpicture *subpicture)
+{
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCDestroySubpicture)(display, subpicture);
+}
+
+Status
+XvMCSetSubpicturePalette (
+    Display *display,
+    XvMCSubpicture *subpicture,
+    unsigned char *palette
+    )
+{
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCSetSubpicturePalette)(display, subpicture, palette);
+}
+
+
+Status
+XvMCBlendSubpicture (
+    Display *display,
+    XvMCSurface *target_surface,
+    XvMCSubpicture *subpicture,
+    short subx,
+    short suby,
+    unsigned short subw,
+    unsigned short subh,
+    short surfx,
+    short surfy,
+    unsigned short surfw,
+    unsigned short surfh
+    )
+{
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCBlendSubpicture)(display, target_surface, subpicture,
+				     subx, suby, subw, subh, surfx, surfy,
+				     surfw, surfh);
+}
+
+Status
+XvMCBlendSubpicture2 (
+    Display *display,
+    XvMCSurface *source_surface,
+    XvMCSurface *target_surface,
+    XvMCSubpicture *subpicture,
+    short subx,
+    short suby,
+    unsigned short subw,
+    unsigned short subh,
+    short surfx,
+    short surfy,
+    unsigned short surfw,
+    unsigned short surfh
+    )
+{
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCBlendSubpicture2)(display, source_surface, target_surface, subpicture,
+				      subx, suby, subw, subh, surfx, surfy, surfw, surfh);
+}
+
+
+Status XvMCSyncSurface (Display *display, XvMCSurface *surface)
+{
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCSyncSurface)(display, surface);
+}
+
+Status XvMCFlushSurface (Display *display, XvMCSurface *surface)
+{
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCFlushSurface)(display, surface);
+}
+
+Status XvMCGetSurfaceStatus (Display *display, XvMCSurface *surface, int *stat)
+{
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCGetSurfaceStatus)(display, surface, stat);
+}
+
+Status XvMCRenderSurface (
+    Display *display,
+    XvMCContext *context,
+    unsigned int picture_structure,
+    XvMCSurface *target_surface,
+    XvMCSurface *past_surface,
+    XvMCSurface *future_surface,
+    unsigned int flags,
+    unsigned int num_macroblocks,
+    unsigned int first_macroblock,
+    XvMCMacroBlockArray *macroblock_array,
+    XvMCBlockArray *blocks
+    )
+{
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCRenderSurface)(display, context, picture_structure, target_surface,
+				   past_surface, future_surface, flags, num_macroblocks,
+				   first_macroblock, macroblock_array, blocks);
+}
+
+Status XvMCSyncSubpicture (Display *display, XvMCSubpicture *subpicture)
+{
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCSyncSubpicture)(display, subpicture);
+}
+
+Status XvMCFlushSubpicture (Display *display, XvMCSubpicture *subpicture)
+{
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCFlushSubpicture)(display, subpicture);
+}
+Status
+XvMCGetSubpictureStatus (Display *display, XvMCSubpicture *subpic, int *stat)
+{
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCGetSubpictureStatus)(display, subpic, stat);
+}
+
+Status XvMCCreateBlocks (
+    Display *display,
+    XvMCContext *context,
+    unsigned int num_blocks,
+    XvMCBlockArray *block
+    )
+{
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCCreateBlocks)(display, context, num_blocks, block);
+}
+
+
+Status XvMCDestroyBlocks (Display *display,XvMCBlockArray *block)
+{
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCDestroyBlocks)(display, block);
+}
+
+Status XvMCCreateMacroBlocks (
+    Display *display,
+    XvMCContext *context,
+    unsigned int num_blocks,
+    XvMCMacroBlockArray *blocks
+    )
+{
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCCreateMacroBlocks)(display, context, num_blocks, blocks);
+}
+
+
+Status XvMCDestroyMacroBlocks (
+    Display *display,
+    XvMCMacroBlockArray *block
+    )
+{
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCDestroyMacroBlocks)(display, block);
+}
+
+
+XvAttribute *
+XvMCQueryAttributes (
+    Display *display,
+    XvMCContext *context,
+    int *number
+    )
+{
+    if (!xW.initialised) return NULL;
+    return (*xW.XvMCQueryAttributes)(display, context, number);
+}
+
+
+Status
+XvMCSetAttribute (
+    Display *display,
+    XvMCContext *context,
+    Atom attribute,
+    int value
+    )
+{
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCSetAttribute)(display, context, attribute, value);
+}
+
+
+Status
+XvMCGetAttribute (
+    Display *display,
+    XvMCContext *context,
+    Atom attribute,
+    int *value
+    )
+{
+    if (!xW.initialised) return BadValue;
+    return (*xW.XvMCGetAttribute)(display, context, attribute, value);
+}
+
+
+Status XvMCBeginSurface(Display *display,
+			XvMCContext *context,
+			XvMCSurface *target_surface,
+			XvMCSurface *past_surface,
+			XvMCSurface *future_surface,
+			const XvMCMpegControl *control)
+{
+    if (!xW.vldextension) return BadValue;
+    return (*xW.XvMCBeginSurface)(display, context, target_surface, past_surface, future_surface,
+				  control);
+}
+
+Status XvMCLoadQMatrix(Display *display, XvMCContext *context,
+		       const XvMCQMatrix *qmx)
+{
+    if (!xW.vldextension) return BadValue;
+    return (*xW.XvMCLoadQMatrix)(display, context, qmx);
+}
+
+Status XvMCPutSlice(Display *display,XvMCContext *context,
+		    char *slice, int nBytes)
+{
+    if (!xW.vldextension) return BadValue;
+    return (*xW.XvMCPutSlice)(display, context, slice, nBytes);
+}
+
+Status XvMCPutSlice2(Display *display,XvMCContext *context,
+		     char *slice, int nBytes, int sliceCode)
+{
+    if (!xW.vldextension) return BadValue;
+    return (*xW.XvMCPutSlice2)(display, context, slice, nBytes, sliceCode);
+}
